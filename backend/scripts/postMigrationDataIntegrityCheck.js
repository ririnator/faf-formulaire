#!/usr/bin/env node

/**
 * POST-MIGRATION DATA INTEGRITY VERIFICATION SCRIPT
 * 
 * Ce script effectue une v√©rification compl√®te de l'int√©grit√© des donn√©es 
 * apr√®s la migration FAF v1 (Response-based) vers Form-a-Friend v2 (User-Submission).
 * 
 * Fonctionnalit√©s:
 * 1. Validation de la migration Response ‚Üí Submission
 * 2. V√©rification de la cr√©ation des comptes User
 * 3. Contr√¥le de l'int√©grit√© des donn√©es
 * 4. Validation des relations User ‚Üî Submission
 * 5. Tests de r√©gression syst√®me
 * 6. Rapport d√©taill√© avec recommandations
 */

const mongoose = require('mongoose');
const fs = require('fs');
const path = require('path');

// Mod√®les de donn√©es
const Response = require('../models/Response');
const Submission = require('../models/Submission');
const User = require('../models/User');
const Invitation = require('../models/Invitation');

// Configuration de la base de donn√©es - utilise .env.test pour la base locale
require('dotenv').config({ path: path.resolve(__dirname, '../.env.test') });

class PostMigrationDataIntegrityChecker {
  constructor() {
    this.report = {
      timestamp: new Date().toISOString(),
      summary: {
        status: 'PENDING',
        totalChecks: 0,
        passedChecks: 0,
        failedChecks: 0,
        criticalIssues: [],
        warnings: []
      },
      data: {
        responses: { total: 0, legacy: 0, migrated: 0 },
        submissions: { total: 0, complete: 0, incomplete: 0 },
        users: { total: 0, migrated: 0, native: 0, admin: 0 },
        invitations: { total: 0, active: 0, expired: 0 }
      },
      integrity: {
        responsesToSubmissions: { status: 'PENDING', details: {} },
        userAccountCreation: { status: 'PENDING', details: {} },
        dataConsistency: { status: 'PENDING', details: {} },
        relationshipValidity: { status: 'PENDING', details: {} },
        backwardCompatibility: { status: 'PENDING', details: {} }
      },
      performance: {
        executionTime: 0,
        memoryUsage: {},
        queryStats: {}
      },
      recommendations: []
    };
    
    this.startTime = Date.now();
    this.queryCount = 0;
  }

  /**
   * Connexion √† la base de donn√©es
   */
  async connectToDatabase() {
    try {
      const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/faf-test';
      await mongoose.connect(mongoUri);
      console.log('‚úÖ Connexion √† MongoDB √©tablie');
      console.log(`üìç Base de donn√©es: ${mongoose.connection.db.databaseName}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur de connexion √† MongoDB:', error.message);
      this.report.summary.criticalIssues.push({
        type: 'DATABASE_CONNECTION',
        message: `Impossible de se connecter √† la base de donn√©es: ${error.message}`,
        timestamp: new Date().toISOString()
      });
      return false;
    }
  }

  /**
   * Collecte des donn√©es de base
   */
  async collectBaseData() {
    console.log('\nüìä Collecte des donn√©es de base...');
    
    try {
      // Comptage des Response
      this.queryCount++;
      this.report.data.responses.total = await Response.countDocuments();
      this.report.data.responses.legacy = await Response.countDocuments({ authMethod: 'token' });
      this.report.data.responses.migrated = await Response.countDocuments({ authMethod: 'user' });
      
      // Comptage des Submission
      this.queryCount++;
      this.report.data.submissions.total = await Submission.countDocuments();
      this.report.data.submissions.complete = await Submission.countDocuments({ isComplete: true });
      this.report.data.submissions.incomplete = await Submission.countDocuments({ isComplete: false });
      
      // Comptage des User
      this.queryCount++;
      this.report.data.users.total = await User.countDocuments();
      this.report.data.users.migrated = await User.countDocuments({ 'migrationData.source': 'migration' });
      this.report.data.users.native = await User.countDocuments({ 'migrationData.source': 'registration' });
      this.report.data.users.admin = await User.countDocuments({ role: 'admin' });
      
      // Comptage des Invitation
      this.queryCount++;
      if (mongoose.models.Invitation) {
        this.report.data.invitations.total = await Invitation.countDocuments();
        this.report.data.invitations.active = await Invitation.countDocuments({ status: 'sent' });
        this.report.data.invitations.expired = await Invitation.countDocuments({ status: 'expired' });
      }
      
      console.log(`   üìà Responses: ${this.report.data.responses.total} (Legacy: ${this.report.data.responses.legacy}, Migrated: ${this.report.data.responses.migrated})`);
      console.log(`   üìù Submissions: ${this.report.data.submissions.total} (Complete: ${this.report.data.submissions.complete})`);
      console.log(`   üë§ Users: ${this.report.data.users.total} (Migrated: ${this.report.data.users.migrated}, Admins: ${this.report.data.users.admin})`);
      console.log(`   üìß Invitations: ${this.report.data.invitations.total}`);
      
      this.report.summary.passedChecks++;
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la collecte des donn√©es:', error.message);
      this.report.summary.criticalIssues.push({
        type: 'DATA_COLLECTION_ERROR',
        message: error.message,
        timestamp: new Date().toISOString()
      });
      this.report.summary.failedChecks++;
    }
    
    this.report.summary.totalChecks++;
  }

  /**
   * V√©rification de la migration Response ‚Üí Submission
   */
  async verifyResponseToSubmissionMigration() {
    console.log('\nüîÑ V√©rification de la migration Response ‚Üí Submission...');
    
    const check = {
      status: 'PENDING',
      details: {
        totalResponses: 0,
        migratedToSubmissions: 0,
        orphanedResponses: [],
        duplicatedSubmissions: [],
        dataIntegrityIssues: [],
        monthlyBreakdown: {}
      }
    };

    try {
      // R√©cup√©ration de tous les Response legacy (avec name)
      this.queryCount++;
      const legacyResponses = await Response.find({ 
        name: { $exists: true, $ne: null },
        authMethod: 'token'
      }).lean();
      
      check.details.totalResponses = legacyResponses.length;
      console.log(`   üìã Responses legacy trouv√©es: ${legacyResponses.length}`);
      
      // V√©rification pour chaque Response
      for (const response of legacyResponses) {
        // Rechercher le User correspondant
        this.queryCount++;
        const user = await User.findOne({ 
          'migrationData.legacyName': response.name 
        }).lean();
        
        if (!user) {
          check.details.orphanedResponses.push({
            responseId: response._id,
            name: response.name,
            month: response.month,
            reason: 'User account not found'
          });
          continue;
        }
        
        // Rechercher la Submission correspondante
        this.queryCount++;
        const submission = await Submission.findOne({
          userId: user._id,
          month: response.month
        }).lean();
        
        if (submission) {
          check.details.migratedToSubmissions++;
          
          // V√©rification de l'int√©grit√© des donn√©es
          if (response.responses && submission.responses) {
            const responseQuestions = response.responses.length;
            const submissionQuestions = submission.responses.length;
            
            if (responseQuestions !== submissionQuestions) {
              check.details.dataIntegrityIssues.push({
                responseId: response._id,
                submissionId: submission._id,
                userName: response.name,
                month: response.month,
                issue: `Question count mismatch: ${responseQuestions} ‚Üí ${submissionQuestions}`
              });
            }
          }
          
          // Statistiques par mois
          if (!check.details.monthlyBreakdown[response.month]) {
            check.details.monthlyBreakdown[response.month] = {
              responses: 0,
              submissions: 0,
              migrationRate: 0
            };
          }
          check.details.monthlyBreakdown[response.month].responses++;
          check.details.monthlyBreakdown[response.month].submissions++;
        } else {
          check.details.orphanedResponses.push({
            responseId: response._id,
            name: response.name,
            month: response.month,
            reason: 'Corresponding submission not found',
            userId: user._id
          });
        }
      }
      
      // Calcul des taux de migration par mois
      for (const month in check.details.monthlyBreakdown) {
        const data = check.details.monthlyBreakdown[month];
        data.migrationRate = data.responses > 0 ? (data.submissions / data.responses) * 100 : 0;
      }
      
      // D√©tection des doublons de Submission
      this.queryCount++;
      const duplicateSubmissions = await Submission.aggregate([
        { $group: { _id: { userId: '$userId', month: '$month' }, count: { $sum: 1 } } },
        { $match: { count: { $gt: 1 } } }
      ]);
      
      check.details.duplicatedSubmissions = duplicateSubmissions;
      
      // √âvaluation du statut
      const migrationRate = check.details.totalResponses > 0 ? 
        (check.details.migratedToSubmissions / check.details.totalResponses) * 100 : 0;
      
      if (migrationRate >= 95 && check.details.dataIntegrityIssues.length === 0) {
        check.status = 'PASSED';
        console.log(`   ‚úÖ Migration r√©ussie: ${migrationRate.toFixed(2)}% (${check.details.migratedToSubmissions}/${check.details.totalResponses})`);
        this.report.summary.passedChecks++;
      } else {
        check.status = 'FAILED';
        console.log(`   ‚ùå Migration incompl√®te: ${migrationRate.toFixed(2)}% (${check.details.migratedToSubmissions}/${check.details.totalResponses})`);
        console.log(`   ‚ö†Ô∏è  Responses orphelines: ${check.details.orphanedResponses.length}`);
        console.log(`   ‚ö†Ô∏è  Probl√®mes d'int√©grit√©: ${check.details.dataIntegrityIssues.length}`);
        this.report.summary.failedChecks++;
        
        this.report.summary.criticalIssues.push({
          type: 'MIGRATION_INCOMPLETE',
          message: `Migration Response ‚Üí Submission incompl√®te (${migrationRate.toFixed(2)}%)`,
          details: {
            orphanedResponses: check.details.orphanedResponses.length,
            integrityIssues: check.details.dataIntegrityIssues.length
          }
        });
      }
      
    } catch (error) {
      check.status = 'ERROR';
      check.details.error = error.message;
      console.error('‚ùå Erreur lors de la v√©rification Response ‚Üí Submission:', error.message);
      this.report.summary.failedChecks++;
      this.report.summary.criticalIssues.push({
        type: 'MIGRATION_CHECK_ERROR',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
    
    this.report.integrity.responsesToSubmissions = check;
    this.report.summary.totalChecks++;
  }

  /**
   * Validation de la cr√©ation des comptes User
   */
  async validateUserAccountCreation() {
    console.log('\nüë§ Validation de la cr√©ation des comptes User...');
    
    const check = {
      status: 'PENDING',
      details: {
        uniqueResponseNames: 0,
        createdUserAccounts: 0,
        missingUserAccounts: [],
        duplicateUsernames: [],
        invalidUserData: [],
        adminAccountsCreated: 0,
        nameToUsernameMapping: {}
      }
    };

    try {
      // R√©cup√©ration des noms uniques des Response legacy
      this.queryCount++;
      const uniqueNames = await Response.distinct('name', { 
        name: { $exists: true, $ne: null },
        authMethod: 'token'
      });
      
      check.details.uniqueResponseNames = uniqueNames.length;
      console.log(`   üìã Noms uniques trouv√©s dans Response: ${uniqueNames.length}`);
      
      // V√©rification pour chaque nom unique
      for (const name of uniqueNames) {
        this.queryCount++;
        const user = await User.findOne({ 
          'migrationData.legacyName': name 
        }).lean();
        
        if (user) {
          check.details.createdUserAccounts++;
          check.details.nameToUsernameMapping[name] = user.username;
          
          // V√©rification du r√¥le admin
          const formAdminName = process.env.FORM_ADMIN_NAME;
          if (formAdminName && name.toLowerCase() === formAdminName.toLowerCase()) {
            if (user.role === 'admin') {
              check.details.adminAccountsCreated++;
            } else {
              check.details.invalidUserData.push({
                name,
                username: user.username,
                issue: `Should be admin but role is: ${user.role}`
              });
            }
          }
          
          // Validation des donn√©es utilisateur
          if (!user.email || !user.username) {
            check.details.invalidUserData.push({
              name,
              userId: user._id,
              issue: 'Missing required fields (email or username)'
            });
          }
          
        } else {
          check.details.missingUserAccounts.push({
            name,
            reason: 'User account not created during migration'
          });
        }
      }
      
      // V√©rification des doublons d'username
      this.queryCount++;
      const duplicateUsernames = await User.aggregate([
        { $group: { _id: '$username', count: { $sum: 1 } } },
        { $match: { count: { $gt: 1 } } }
      ]);
      
      check.details.duplicateUsernames = duplicateUsernames.map(dup => ({
        username: dup._id,
        count: dup.count
      }));
      
      // √âvaluation du statut
      const accountCreationRate = check.details.uniqueResponseNames > 0 ? 
        (check.details.createdUserAccounts / check.details.uniqueResponseNames) * 100 : 0;
      
      if (accountCreationRate >= 100 && 
          check.details.duplicateUsernames.length === 0 && 
          check.details.invalidUserData.length === 0) {
        check.status = 'PASSED';
        console.log(`   ‚úÖ Cr√©ation des comptes r√©ussie: ${accountCreationRate}% (${check.details.createdUserAccounts}/${check.details.uniqueResponseNames})`);
        console.log(`   üëë Comptes admin cr√©√©s: ${check.details.adminAccountsCreated}`);
        this.report.summary.passedChecks++;
      } else {
        check.status = 'FAILED';
        console.log(`   ‚ùå Cr√©ation des comptes incompl√®te: ${accountCreationRate.toFixed(2)}%`);
        console.log(`   ‚ö†Ô∏è  Comptes manquants: ${check.details.missingUserAccounts.length}`);
        console.log(`   ‚ö†Ô∏è  Doublons username: ${check.details.duplicateUsernames.length}`);
        console.log(`   ‚ö†Ô∏è  Donn√©es invalides: ${check.details.invalidUserData.length}`);
        this.report.summary.failedChecks++;
        
        this.report.summary.criticalIssues.push({
          type: 'USER_CREATION_INCOMPLETE',
          message: `Cr√©ation des comptes User incompl√®te (${accountCreationRate.toFixed(2)}%)`,
          details: {
            missingAccounts: check.details.missingUserAccounts.length,
            duplicateUsernames: check.details.duplicateUsernames.length,
            invalidData: check.details.invalidUserData.length
          }
        });
      }
      
    } catch (error) {
      check.status = 'ERROR';
      check.details.error = error.message;
      console.error('‚ùå Erreur lors de la validation des comptes User:', error.message);
      this.report.summary.failedChecks++;
      this.report.summary.criticalIssues.push({
        type: 'USER_VALIDATION_ERROR',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
    
    this.report.integrity.userAccountCreation = check;
    this.report.summary.totalChecks++;
  }

  /**
   * Contr√¥le de l'int√©grit√© et corruption des donn√©es
   */
  async checkDataIntegrityAndCorruption() {
    console.log('\nüîç Contr√¥le de l\'int√©grit√© et corruption des donn√©es...');
    
    const check = {
      status: 'PENDING',
      details: {
        corruptedResponses: [],
        corruptedSubmissions: [],
        corruptedUsers: [],
        missingFields: [],
        invalidDates: [],
        orphanedData: [],
        schemaViolations: []
      }
    };

    try {
      // V√©rification des Response corrompues
      this.queryCount++;
      const responses = await Response.find({}).lean();
      
      for (const response of responses) {
        const issues = [];
        
        // V√©rification des champs requis
        if (!response.month) issues.push('Missing month field');
        if (!response.createdAt) issues.push('Missing createdAt field');
        if (!response.responses || !Array.isArray(response.responses)) {
          issues.push('Missing or invalid responses array');
        }
        
        // V√©rification du format du mois
        if (response.month && !/^\d{4}-\d{2}$/.test(response.month)) {
          issues.push(`Invalid month format: ${response.month}`);
        }
        
        // V√©rification des dates
        if (response.createdAt && isNaN(Date.parse(response.createdAt))) {
          issues.push('Invalid createdAt date');
        }
        
        // V√©rification de la coh√©rence authMethod
        if (response.authMethod === 'user' && !response.userId) {
          issues.push('Missing userId for user authMethod');
        }
        if (response.authMethod === 'token' && !response.name) {
          issues.push('Missing name for token authMethod');
        }
        
        if (issues.length > 0) {
          check.details.corruptedResponses.push({
            id: response._id,
            issues
          });
        }
      }
      
      // V√©rification des Submission corrompues
      this.queryCount++;
      const submissions = await Submission.find({}).lean();
      
      for (const submission of submissions) {
        const issues = [];
        
        // V√©rification des champs requis
        if (!submission.userId) issues.push('Missing userId field');
        if (!submission.month) issues.push('Missing month field');
        if (!submission.responses || !Array.isArray(submission.responses)) {
          issues.push('Missing or invalid responses array');
        }
        
        // V√©rification du format du mois
        if (submission.month && !/^\d{4}-\d{2}$/.test(submission.month)) {
          issues.push(`Invalid month format: ${submission.month}`);
        }
        
        // V√©rification des dates
        if (submission.submittedAt && isNaN(Date.parse(submission.submittedAt))) {
          issues.push('Invalid submittedAt date');
        }
        
        // V√©rification de la coh√©rence completionRate
        if (typeof submission.completionRate !== 'number' || 
            submission.completionRate < 0 || 
            submission.completionRate > 100) {
          issues.push(`Invalid completionRate: ${submission.completionRate}`);
        }
        
        if (issues.length > 0) {
          check.details.corruptedSubmissions.push({
            id: submission._id,
            issues
          });
        }
      }
      
      // V√©rification des User corrompus
      this.queryCount++;
      const users = await User.find({}).lean();
      
      for (const user of users) {
        const issues = [];
        
        // V√©rification des champs requis
        if (!user.username) issues.push('Missing username field');
        if (!user.email) issues.push('Missing email field');
        if (!user.password) issues.push('Missing password field');
        
        // V√©rification du format email
        if (user.email && !/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/.test(user.email)) {
          issues.push(`Invalid email format: ${user.email}`);
        }
        
        // V√©rification de la longueur username
        if (user.username && (user.username.length < 3 || user.username.length > 30)) {
          issues.push(`Invalid username length: ${user.username.length}`);
        }
        
        // V√©rification du r√¥le
        if (user.role && !['user', 'admin'].includes(user.role)) {
          issues.push(`Invalid role: ${user.role}`);
        }
        
        if (issues.length > 0) {
          check.details.corruptedUsers.push({
            id: user._id,
            username: user.username,
            issues
          });
        }
      }
      
      // V√©rification des donn√©es orphelines (Submission sans User)
      this.queryCount++;
      const orphanedSubmissions = await Submission.aggregate([
        {
          $lookup: {
            from: 'users',
            localField: 'userId',
            foreignField: '_id',
            as: 'user'
          }
        },
        { $match: { user: { $size: 0 } } }
      ]);
      
      check.details.orphanedData = orphanedSubmissions.map(sub => ({
        type: 'Submission',
        id: sub._id,
        userId: sub.userId,
        month: sub.month
      }));
      
      // √âvaluation du statut
      const totalIssues = check.details.corruptedResponses.length + 
                         check.details.corruptedSubmissions.length + 
                         check.details.corruptedUsers.length + 
                         check.details.orphanedData.length;
      
      if (totalIssues === 0) {
        check.status = 'PASSED';
        console.log('   ‚úÖ Aucune corruption de donn√©es d√©tect√©e');
        this.report.summary.passedChecks++;
      } else {
        check.status = 'FAILED';
        console.log(`   ‚ùå ${totalIssues} probl√®mes d'int√©grit√© d√©tect√©s:`);
        console.log(`      - Responses corrompues: ${check.details.corruptedResponses.length}`);
        console.log(`      - Submissions corrompues: ${check.details.corruptedSubmissions.length}`);
        console.log(`      - Users corrompus: ${check.details.corruptedUsers.length}`);
        console.log(`      - Donn√©es orphelines: ${check.details.orphanedData.length}`);
        this.report.summary.failedChecks++;
        
        this.report.summary.criticalIssues.push({
          type: 'DATA_CORRUPTION',
          message: `${totalIssues} probl√®mes d'int√©grit√© de donn√©es d√©tect√©s`,
          details: {
            corruptedResponses: check.details.corruptedResponses.length,
            corruptedSubmissions: check.details.corruptedSubmissions.length,
            corruptedUsers: check.details.corruptedUsers.length,
            orphanedData: check.details.orphanedData.length
          }
        });
      }
      
    } catch (error) {
      check.status = 'ERROR';
      check.details.error = error.message;
      console.error('‚ùå Erreur lors du contr√¥le d\'int√©grit√©:', error.message);
      this.report.summary.failedChecks++;
      this.report.summary.criticalIssues.push({
        type: 'INTEGRITY_CHECK_ERROR',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
    
    this.report.integrity.dataConsistency = check;
    this.report.summary.totalChecks++;
  }

  /**
   * Validation des relations User ‚Üî Submission
   */
  async validateUserSubmissionRelationships() {
    console.log('\nüîó Validation des relations User ‚Üî Submission...');
    
    const check = {
      status: 'PENDING',
      details: {
        totalSubmissions: 0,
        validRelationships: 0,
        brokenRelationships: [],
        missingUsers: [],
        inconsistentData: [],
        statisticsErrors: []
      }
    };

    try {
      // R√©cup√©ration de toutes les Submission
      this.queryCount++;
      const submissions = await Submission.find({}).populate('userId').lean();
      check.details.totalSubmissions = submissions.length;
      
      console.log(`   üìã Submissions √† v√©rifier: ${submissions.length}`);
      
      for (const submission of submissions) {
        if (!submission.userId) {
          check.details.missingUsers.push({
            submissionId: submission._id,
            month: submission.month,
            reason: 'userId is null or undefined'
          });
          continue;
        }
        
        // Si populate a √©chou√©, l'utilisateur n'existe pas
        if (!submission.userId.username) {
          check.details.brokenRelationships.push({
            submissionId: submission._id,
            userId: submission.userId._id || submission.userId,
            month: submission.month,
            reason: 'Referenced user does not exist'
          });
          continue;
        }
        
        check.details.validRelationships++;
        
        // V√©rification des statistiques utilisateur
        const user = submission.userId;
        
        // Comptage r√©el des submissions de cet utilisateur
        this.queryCount++;
        const actualSubmissionCount = await Submission.countDocuments({ userId: user._id });
        
        if (user.statistics && user.statistics.totalSubmissions !== actualSubmissionCount) {
          check.details.statisticsErrors.push({
            userId: user._id,
            username: user.username,
            recordedCount: user.statistics.totalSubmissions,
            actualCount: actualSubmissionCount,
            difference: actualSubmissionCount - user.statistics.totalSubmissions
          });
        }
        
        // V√©rification de la coh√©rence responseCount (legacy)
        if (user.metadata && user.metadata.responseCount) {
          const totalResponses = actualSubmissionCount; // Dans le nouveau syst√®me
          if (user.metadata.responseCount !== totalResponses) {
            check.details.inconsistentData.push({
              userId: user._id,
              username: user.username,
              field: 'responseCount',
              recorded: user.metadata.responseCount,
              actual: totalResponses
            });
          }
        }
      }
      
      // V√©rification inverse: Users sans Submission qui devraient en avoir
      this.queryCount++;
      const migratedUsers = await User.find({ 
        'migrationData.source': 'migration' 
      }).lean();
      
      for (const user of migratedUsers) {
        this.queryCount++;
        const submissionCount = await Submission.countDocuments({ userId: user._id });
        
        if (submissionCount === 0) {
          // V√©rifier s'il y avait des Response legacy pour ce nom
          this.queryCount++;
          const legacyResponseCount = await Response.countDocuments({ 
            name: user.migrationData.legacyName,
            authMethod: 'token'
          });
          
          if (legacyResponseCount > 0) {
            check.details.brokenRelationships.push({
              userId: user._id,
              username: user.username,
              legacyName: user.migrationData.legacyName,
              reason: `User has ${legacyResponseCount} legacy Response but no Submission`
            });
          }
        }
      }
      
      // √âvaluation du statut
      const relationshipValidityRate = check.details.totalSubmissions > 0 ? 
        (check.details.validRelationships / check.details.totalSubmissions) * 100 : 100;
      
      if (relationshipValidityRate >= 98 && 
          check.details.brokenRelationships.length === 0 &&
          check.details.statisticsErrors.length <= 5) { // Tol√©rance pour les stats
        check.status = 'PASSED';
        console.log(`   ‚úÖ Relations valides: ${relationshipValidityRate.toFixed(2)}% (${check.details.validRelationships}/${check.details.totalSubmissions})`);
        if (check.details.statisticsErrors.length > 0) {
          console.log(`   ‚ö†Ô∏è  Erreurs statistiques mineures: ${check.details.statisticsErrors.length}`);
        }
        this.report.summary.passedChecks++;
      } else {
        check.status = 'FAILED';
        console.log(`   ‚ùå Relations invalides: ${(100 - relationshipValidityRate).toFixed(2)}%`);
        console.log(`   ‚ö†Ô∏è  Relations bris√©es: ${check.details.brokenRelationships.length}`);
        console.log(`   ‚ö†Ô∏è  Utilisateurs manquants: ${check.details.missingUsers.length}`);
        console.log(`   ‚ö†Ô∏è  Erreurs statistiques: ${check.details.statisticsErrors.length}`);
        this.report.summary.failedChecks++;
        
        this.report.summary.criticalIssues.push({
          type: 'RELATIONSHIP_VALIDATION_FAILED',
          message: `Relations User ‚Üî Submission invalides (${(100 - relationshipValidityRate).toFixed(2)}% d'erreur)`,
          details: {
            brokenRelationships: check.details.brokenRelationships.length,
            missingUsers: check.details.missingUsers.length,
            statisticsErrors: check.details.statisticsErrors.length
          }
        });
      }
      
    } catch (error) {
      check.status = 'ERROR';
      check.details.error = error.message;
      console.error('‚ùå Erreur lors de la validation des relations:', error.message);
      this.report.summary.failedChecks++;
      this.report.summary.criticalIssues.push({
        type: 'RELATIONSHIP_CHECK_ERROR',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
    
    this.report.integrity.relationshipValidity = check;
    this.report.summary.totalChecks++;
  }

  /**
   * Tests de r√©gression pour l'ancien syst√®me
   */
  async runRegressionTests() {
    console.log('\nüî¨ Tests de r√©gression pour l\'ancien syst√®me...');
    
    const check = {
      status: 'PENDING',
      details: {
        legacyTokensWorking: 0,
        brokenTokens: [],
        legacyDataAccessible: 0,
        inaccessibleLegacyData: [],
        authMethodConsistency: [],
        hybridSystemIssues: []
      }
    };

    try {
      // Test 1: V√©rification des tokens legacy
      this.queryCount++;
      const legacyResponses = await Response.find({ 
        token: { $exists: true, $ne: null },
        authMethod: 'token'
      }).lean();
      
      console.log(`   üîë Tokens legacy √† tester: ${legacyResponses.length}`);
      
      for (const response of legacyResponses) {
        // V√©rifier que le token est toujours unique
        this.queryCount++;
        const duplicateTokens = await Response.countDocuments({ token: response.token });
        
        if (duplicateTokens === 1) {
          check.details.legacyTokensWorking++;
        } else {
          check.details.brokenTokens.push({
            responseId: response._id,
            token: response.token,
            duplicateCount: duplicateTokens,
            name: response.name,
            month: response.month
          });
        }
      }
      
      // Test 2: Accessibilit√© des donn√©es legacy
      this.queryCount++;
      const responsesWithData = await Response.find({
        authMethod: 'token',
        responses: { $exists: true, $not: { $size: 0 } }
      }).lean();
      
      for (const response of responsesWithData) {
        // V√©rifier que les donn√©es sont toujours structur√©es correctement
        let accessible = true;
        let issues = [];
        
        if (!response.responses || !Array.isArray(response.responses)) {
          accessible = false;
          issues.push('responses field is not an array');
        } else {
          for (const resp of response.responses) {
            if (!resp.question || !resp.answer) {
              accessible = false;
              issues.push('Missing question or answer in response');
              break;
            }
          }
        }
        
        if (accessible) {
          check.details.legacyDataAccessible++;
        } else {
          check.details.inaccessibleLegacyData.push({
            responseId: response._id,
            name: response.name,
            month: response.month,
            issues
          });
        }
      }
      
      // Test 3: Coh√©rence des authMethod
      this.queryCount++;
      const inconsistentAuthMethods = await Response.find({
        $or: [
          { authMethod: 'token', name: { $exists: false } },
          { authMethod: 'token', token: { $exists: false } },
          { authMethod: 'user', userId: { $exists: false } },
          { authMethod: 'user', name: { $exists: true, $ne: null } }
        ]
      }).lean();
      
      check.details.authMethodConsistency = inconsistentAuthMethods.map(resp => ({
        responseId: resp._id,
        authMethod: resp.authMethod,
        hasName: !!resp.name,
        hasToken: !!resp.token,
        hasUserId: !!resp.userId,
        month: resp.month
      }));
      
      // Test 4: V√©rification du syst√®me hybride
      // Chercher des conflits potentiels entre ancien et nouveau syst√®me
      this.queryCount++;
      const hybridConflicts = await Response.aggregate([
        {
          $group: {
            _id: { month: '$month', name: '$name' },
            authMethods: { $addToSet: '$authMethod' },
            count: { $sum: 1 }
          }
        },
        {
          $match: {
            'authMethods.1': { $exists: true } // Plus d'une m√©thode d'auth
          }
        }
      ]);
      
      check.details.hybridSystemIssues = hybridConflicts;
      
      // √âvaluation du statut
      const tokenSuccessRate = legacyResponses.length > 0 ? 
        (check.details.legacyTokensWorking / legacyResponses.length) * 100 : 100;
      const dataAccessRate = responsesWithData.length > 0 ? 
        (check.details.legacyDataAccessible / responsesWithData.length) * 100 : 100;
      
      if (tokenSuccessRate >= 95 && 
          dataAccessRate >= 95 && 
          check.details.authMethodConsistency.length === 0 &&
          check.details.hybridSystemIssues.length === 0) {
        check.status = 'PASSED';
        console.log(`   ‚úÖ Syst√®me legacy fonctionnel:`);
        console.log(`      - Tokens valides: ${tokenSuccessRate.toFixed(2)}% (${check.details.legacyTokensWorking}/${legacyResponses.length})`);
        console.log(`      - Donn√©es accessibles: ${dataAccessRate.toFixed(2)}% (${check.details.legacyDataAccessible}/${responsesWithData.length})`);
        this.report.summary.passedChecks++;
      } else {
        check.status = 'FAILED';
        console.log(`   ‚ùå Probl√®mes d√©tect√©s dans le syst√®me legacy:`);
        console.log(`      - Tokens cass√©s: ${check.details.brokenTokens.length}`);
        console.log(`      - Donn√©es inaccessibles: ${check.details.inaccessibleLegacyData.length}`);
        console.log(`      - Incoh√©rences authMethod: ${check.details.authMethodConsistency.length}`);
        console.log(`      - Conflits syst√®me hybride: ${check.details.hybridSystemIssues.length}`);
        this.report.summary.failedChecks++;
        
        this.report.summary.criticalIssues.push({
          type: 'REGRESSION_TEST_FAILED',
          message: 'Tests de r√©gression √©chou√©s pour le syst√®me legacy',
          details: {
            brokenTokens: check.details.brokenTokens.length,
            inaccessibleData: check.details.inaccessibleLegacyData.length,
            authMethodIssues: check.details.authMethodConsistency.length,
            hybridIssues: check.details.hybridSystemIssues.length
          }
        });
      }
      
    } catch (error) {
      check.status = 'ERROR';
      check.details.error = error.message;
      console.error('‚ùå Erreur lors des tests de r√©gression:', error.message);
      this.report.summary.failedChecks++;
      this.report.summary.criticalIssues.push({
        type: 'REGRESSION_TEST_ERROR',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
    
    this.report.integrity.backwardCompatibility = check;
    this.report.summary.totalChecks++;
  }

  /**
   * G√©n√©ration des recommandations
   */
  generateRecommendations() {
    console.log('\nüí° G√©n√©ration des recommandations...');
    
    const recommendations = [];
    
    // Recommandations bas√©es sur les r√©sultats des v√©rifications
    if (this.report.integrity.responsesToSubmissions.status === 'FAILED') {
      const details = this.report.integrity.responsesToSubmissions.details;
      
      if (details.orphanedResponses && details.orphanedResponses.length > 0) {
        recommendations.push({
          priority: 'HIGH',
          category: 'MIGRATION',
          title: 'Responses orphelines d√©tect√©es',
          description: `${details.orphanedResponses.length} Response n'ont pas √©t√© migr√©es vers Submission`,
          action: 'Ex√©cuter un script de migration compl√©mentaire pour traiter les Response orphelines',
          impact: 'CRITICAL',
          automatable: true
        });
      }
      
      if (details.dataIntegrityIssues && details.dataIntegrityIssues.length > 0) {
        recommendations.push({
          priority: 'HIGH',
          category: 'DATA_INTEGRITY',
          title: 'Probl√®mes d\'int√©grit√© de donn√©es',
          description: `${details.dataIntegrityIssues.length} probl√®mes d'int√©grit√© d√©tect√©s lors de la migration`,
          action: 'R√©viser et corriger les donn√©es corrompues ou incompl√®tes',
          impact: 'HIGH',
          automatable: false
        });
      }
    }
    
    if (this.report.integrity.userAccountCreation.status === 'FAILED') {
      const details = this.report.integrity.userAccountCreation.details;
      
      if (details.missingUserAccounts && details.missingUserAccounts.length > 0) {
        recommendations.push({
          priority: 'HIGH',
          category: 'USER_MANAGEMENT',
          title: 'Comptes utilisateur manquants',
          description: `${details.missingUserAccounts.length} comptes utilisateur n'ont pas √©t√© cr√©√©s`,
          action: 'Cr√©er les comptes utilisateur manquants avec les param√®tres par d√©faut',
          impact: 'HIGH',
          automatable: true
        });
      }
      
      if (details.duplicateUsernames && details.duplicateUsernames.length > 0) {
        recommendations.push({
          priority: 'CRITICAL',
          category: 'DATA_INTEGRITY',
          title: 'Doublons d\'username d√©tect√©s',
          description: `${details.duplicateUsernames.length} usernames dupliqu√©s violent les contraintes uniques`,
          action: 'R√©soudre les conflits d\'username en appliquant une strat√©gie de nommage coh√©rente',
          impact: 'CRITICAL',
          automatable: false
        });
      }
    }
    
    if (this.report.integrity.dataConsistency.status === 'FAILED') {
      const details = this.report.integrity.dataConsistency.details;
      
      if (details.orphanedData && details.orphanedData.length > 0) {
        recommendations.push({
          priority: 'MEDIUM',
          category: 'DATA_CLEANUP',
          title: 'Donn√©es orphelines d√©tect√©es',
          description: `${details.orphanedData.length} enregistrements orphelins sans r√©f√©rences valides`,
          action: 'Nettoyer les donn√©es orphelines ou r√©tablir les r√©f√©rences manquantes',
          impact: 'MEDIUM',
          automatable: true
        });
      }
      
      const totalCorrupted = (details.corruptedResponses?.length || 0) + 
                           (details.corruptedSubmissions?.length || 0) + 
                           (details.corruptedUsers?.length || 0);
      
      if (totalCorrupted > 0) {
        recommendations.push({
          priority: 'HIGH',
          category: 'DATA_INTEGRITY',
          title: 'Donn√©es corrompues d√©tect√©es',
          description: `${totalCorrupted} enregistrements avec des donn√©es corrompues ou invalides`,
          action: 'R√©parer ou supprimer les enregistrements corrompus selon la criticit√©',
          impact: 'HIGH',
          automatable: false
        });
      }
    }
    
    if (this.report.integrity.relationshipValidity.status === 'FAILED') {
      const details = this.report.integrity.relationshipValidity.details;
      
      if (details.brokenRelationships && details.brokenRelationships.length > 0) {
        recommendations.push({
          priority: 'HIGH',
          category: 'RELATIONSHIP_INTEGRITY',
          title: 'Relations bris√©es User ‚Üî Submission',
          description: `${details.brokenRelationships.length} relations bris√©es entre User et Submission`,
          action: 'R√©tablir les r√©f√©rences manquantes ou supprimer les enregistrements orphelins',
          impact: 'HIGH',
          automatable: true
        });
      }
      
      if (details.statisticsErrors && details.statisticsErrors.length > 0) {
        recommendations.push({
          priority: 'LOW',
          category: 'DATA_CONSISTENCY',
          title: 'Statistiques utilisateur incoh√©rentes',
          description: `${details.statisticsErrors.length} utilisateurs avec des statistiques incorrectes`,
          action: 'Recalculer les statistiques utilisateur √† partir des donn√©es r√©elles',
          impact: 'LOW',
          automatable: true
        });
      }
    }
    
    if (this.report.integrity.backwardCompatibility.status === 'FAILED') {
      const details = this.report.integrity.backwardCompatibility.details;
      
      if (details.brokenTokens && details.brokenTokens.length > 0) {
        recommendations.push({
          priority: 'HIGH',
          category: 'BACKWARD_COMPATIBILITY',
          title: 'Tokens legacy cass√©s',
          description: `${details.brokenTokens.length} tokens legacy ne fonctionnent plus correctement`,
          action: 'R√©g√©n√©rer ou corriger les tokens legacy pour maintenir la compatibilit√©',
          impact: 'HIGH',
          automatable: true
        });
      }
      
      if (details.hybridSystemIssues && details.hybridSystemIssues.length > 0) {
        recommendations.push({
          priority: 'MEDIUM',
          category: 'SYSTEM_ARCHITECTURE',
          title: 'Conflits syst√®me hybride',
          description: `${details.hybridSystemIssues.length} conflits d√©tect√©s dans le syst√®me hybride`,
          action: 'R√©soudre les conflits entre ancien et nouveau syst√®me d\'authentification',
          impact: 'MEDIUM',
          automatable: false
        });
      }
    }
    
    // Recommandations g√©n√©rales bas√©es sur les performances
    if (this.queryCount > 100) {
      recommendations.push({
        priority: 'LOW',
        category: 'PERFORMANCE',
        title: 'Optimisation des requ√™tes de v√©rification',
        description: `${this.queryCount} requ√™tes ex√©cut√©es pendant la v√©rification`,
        action: 'Optimiser les index de base de donn√©es pour am√©liorer les performances',
        impact: 'LOW',
        automatable: true
      });
    }
    
    // Recommandations pr√©ventives
    recommendations.push({
      priority: 'MEDIUM',
      category: 'MONITORING',
      title: 'Surveillance continue de l\'int√©grit√©',
      description: 'Mettre en place une surveillance r√©guli√®re de l\'int√©grit√© des donn√©es',
      action: 'Programmer des v√©rifications d\'int√©grit√© automatiques hebdomadaires',
      impact: 'MEDIUM',
      automatable: true
    });
    
    recommendations.push({
      priority: 'LOW',
      category: 'DOCUMENTATION',
      title: 'Documentation des proc√©dures de migration',
      description: 'Documenter les le√ßons apprises et les bonnes pratiques',
      action: 'Cr√©er un guide de migration et de maintenance pour les futures versions',
      impact: 'LOW',
      automatable: false
    });
    
    this.report.recommendations = recommendations;
    
    console.log(`   üìã ${recommendations.length} recommandations g√©n√©r√©es`);
    console.log(`      - Priorit√© CRITICAL: ${recommendations.filter(r => r.priority === 'CRITICAL').length}`);
    console.log(`      - Priorit√© HIGH: ${recommendations.filter(r => r.priority === 'HIGH').length}`);
    console.log(`      - Priorit√© MEDIUM: ${recommendations.filter(r => r.priority === 'MEDIUM').length}`);
    console.log(`      - Priorit√© LOW: ${recommendations.filter(r => r.priority === 'LOW').length}`);
  }

  /**
   * Finalisation du rapport et calcul des m√©triques
   */
  finalizeReport() {
    const endTime = Date.now();
    this.report.performance.executionTime = endTime - this.startTime;
    this.report.performance.memoryUsage = process.memoryUsage();
    this.report.performance.queryStats = {
      totalQueries: this.queryCount,
      averageQueryTime: this.report.performance.executionTime / this.queryCount
    };
    
    // D√©termination du statut global
    const successRate = this.report.summary.totalChecks > 0 ? 
      (this.report.summary.passedChecks / this.report.summary.totalChecks) * 100 : 0;
    
    if (successRate >= 95 && this.report.summary.criticalIssues.length === 0) {
      this.report.summary.status = 'PASSED';
    } else if (successRate >= 80 && this.report.summary.criticalIssues.length <= 2) {
      this.report.summary.status = 'WARNING';
    } else {
      this.report.summary.status = 'FAILED';
    }
    
    console.log('\nüìä R√âSUM√â DE LA V√âRIFICATION:');
    console.log(`   üéØ Statut global: ${this.report.summary.status}`);
    console.log(`   ‚úÖ Tests r√©ussis: ${this.report.summary.passedChecks}/${this.report.summary.totalChecks} (${successRate.toFixed(2)}%)`);
    console.log(`   ‚ùå Tests √©chou√©s: ${this.report.summary.failedChecks}`);
    console.log(`   üö® Probl√®mes critiques: ${this.report.summary.criticalIssues.length}`);
    console.log(`   ‚ö†Ô∏è  Avertissements: ${this.report.summary.warnings.length}`);
    console.log(`   ‚è±Ô∏è  Temps d'ex√©cution: ${(this.report.performance.executionTime / 1000).toFixed(2)}s`);
    console.log(`   üìä Requ√™tes ex√©cut√©es: ${this.queryCount}`);
  }

  /**
   * Sauvegarde du rapport
   */
  async saveReport() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `post-migration-integrity-report-${timestamp}.json`;
    const filepath = path.join(__dirname, '../reports', filename);
    
    try {
      // Cr√©er le dossier reports s'il n'existe pas
      const reportsDir = path.dirname(filepath);
      if (!fs.existsSync(reportsDir)) {
        fs.mkdirSync(reportsDir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, JSON.stringify(this.report, null, 2));
      console.log(`\nüíæ Rapport sauvegard√©: ${filepath}`);
      
      // Cr√©er aussi un lien vers le dernier rapport
      const latestPath = path.join(reportsDir, 'latest-integrity-report.json');
      if (fs.existsSync(latestPath)) {
        fs.unlinkSync(latestPath);
      }
      fs.symlinkSync(filename, latestPath);
      
      return filepath;
    } catch (error) {
      console.error('‚ùå Erreur lors de la sauvegarde du rapport:', error.message);
      return null;
    }
  }

  /**
   * Ex√©cution compl√®te de la v√©rification
   */
  async run() {
    console.log('üîç POST-MIGRATION DATA INTEGRITY VERIFICATION');
    console.log('============================================');
    console.log(`üìÖ D√©marr√© le: ${new Date().toLocaleString()}`);
    console.log(`üóÑÔ∏è  Base de donn√©es: ${process.env.MONGODB_URI || 'mongodb://localhost:27017/faf-test'}`);
    
    // Connexion √† la base de donn√©es
    const connected = await this.connectToDatabase();
    if (!connected) {
      this.finalizeReport();
      await this.saveReport();
      return this.report;
    }
    
    try {
      // √âtapes de v√©rification
      await this.collectBaseData();
      await this.verifyResponseToSubmissionMigration();
      await this.validateUserAccountCreation();
      await this.checkDataIntegrityAndCorruption();
      await this.validateUserSubmissionRelationships();
      await this.runRegressionTests();
      
      // G√©n√©ration du rapport final
      this.generateRecommendations();
      this.finalizeReport();
      
    } catch (error) {
      console.error('‚ùå Erreur fatale pendant la v√©rification:', error);
      this.report.summary.status = 'ERROR';
      this.report.summary.criticalIssues.push({
        type: 'FATAL_ERROR',
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
    } finally {
      // Fermeture de la connexion
      await mongoose.connection.close();
      console.log('‚úÖ Connexion √† MongoDB ferm√©e');
      
      // Sauvegarde du rapport
      await this.saveReport();
    }
    
    return this.report;
  }
}

// Ex√©cution si appel√© directement
if (require.main === module) {
  const checker = new PostMigrationDataIntegrityChecker();
  checker.run().then((report) => {
    console.log('\nüèÅ V√©rification termin√©e');
    
    if (report.summary.status === 'PASSED') {
      console.log('üéâ Migration valid√©e avec succ√®s !');
      process.exit(0);
    } else if (report.summary.status === 'WARNING') {
      console.log('‚ö†Ô∏è  Migration partiellement valid√©e - V√©rifier les avertissements');
      process.exit(1);
    } else {
      console.log('‚ùå Migration √©chou√©e - Action requise');
      process.exit(2);
    }
  }).catch((error) => {
    console.error('üí• Erreur fatale:', error);
    process.exit(3);
  });
}

module.exports = PostMigrationDataIntegrityChecker;