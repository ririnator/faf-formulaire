#!/usr/bin/env node

/**
 * EXECUTEUR DE TEST D'INTEGRITE AVEC MONGODB MEMORY SERVER
 * 
 * Ce script lance un serveur MongoDB en m√©moire, g√©n√®re des donn√©es de test,
 * puis ex√©cute la v√©rification compl√®te d'int√©grit√© des donn√©es.
 */

const { MongoMemoryServer } = require('mongodb-memory-server');
const mongoose = require('mongoose');
const TestDataGenerator = require('./generateTestData');
const PostMigrationDataIntegrityChecker = require('./postMigrationDataIntegrityCheck');

class IntegrityTestRunner {
  constructor() {
    this.mongod = null;
    this.mongoUri = null;
  }

  async startMongoMemoryServer() {
    console.log('üöÄ D√©marrage de MongoDB Memory Server...');
    
    try {
      this.mongod = await MongoMemoryServer.create({
        instance: {
          dbName: 'faf-test-integrity'
        }
      });
      
      this.mongoUri = this.mongod.getUri();
      console.log(`‚úÖ MongoDB Memory Server d√©marr√© sur: ${this.mongoUri}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur lors du d√©marrage de MongoDB Memory Server:', error.message);
      return false;
    }
  }

  async stopMongoMemoryServer() {
    if (this.mongod) {
      console.log('üõë Arr√™t de MongoDB Memory Server...');
      await this.mongod.stop();
      console.log('‚úÖ MongoDB Memory Server arr√™t√©');
    }
  }

  async generateTestData() {
    console.log('\nüìä G√©n√©ration des donn√©es de test...');
    
    // Configurer l'URI pour le g√©n√©rateur de donn√©es
    process.env.MONGODB_URI = this.mongoUri;
    
    const generator = new TestDataGenerator();
    
    // Override de la m√©thode de connexion pour utiliser notre URI
    generator.connectToDatabase = async () => {
      try {
        await mongoose.connect(this.mongoUri);
        console.log('‚úÖ Connexion √† MongoDB Memory Server √©tablie (g√©n√©rateur)');
        return true;
      } catch (error) {
        console.error('‚ùå Erreur de connexion:', error.message);
        return false;
      }
    };
    
    const success = await generator.run();
    return success;
  }

  async runIntegrityCheck() {
    console.log('\nüîç Ex√©cution de la v√©rification d\'int√©grit√©...');
    
    // Configurer l'URI pour le v√©rificateur
    process.env.MONGODB_URI = this.mongoUri;
    
    const checker = new PostMigrationDataIntegrityChecker();
    
    // Override de la m√©thode de connexion pour utiliser notre URI
    checker.connectToDatabase = async () => {
      try {
        await mongoose.connect(this.mongoUri);
        console.log('‚úÖ Connexion √† MongoDB Memory Server √©tablie (v√©rificateur)');
        return true;
      } catch (error) {
        console.error('‚ùå Erreur de connexion:', error.message);
        checker.report.summary.criticalIssues.push({
          type: 'DATABASE_CONNECTION',
          message: `Impossible de se connecter √† la base de donn√©es: ${error.message}`,
          timestamp: new Date().toISOString()
        });
        return false;
      }
    };
    
    const report = await checker.run();
    return report;
  }

  async displayDetailedResults(report) {
    console.log('\nüìã ANALYSE DETAILLEE DES RESULTATS');
    console.log('==================================');
    
    // Statut global
    const statusEmoji = {
      'PASSED': '‚úÖ',
      'WARNING': '‚ö†Ô∏è',
      'FAILED': '‚ùå',
      'ERROR': 'üí•'
    };
    
    console.log(`${statusEmoji[report.summary.status]} Statut global: ${report.summary.status}`);
    console.log(`üìä Score de r√©ussite: ${report.summary.passedChecks}/${report.summary.totalChecks} (${((report.summary.passedChecks / report.summary.totalChecks) * 100).toFixed(2)}%)`);
    
    // Donn√©es de base
    console.log('\nüìà DONNEES DE BASE:');
    console.log(`   Response: ${report.data.responses.total} (Legacy: ${report.data.responses.legacy}, Migr√©es: ${report.data.responses.migrated})`);
    console.log(`   Submission: ${report.data.submissions.total} (Compl√®tes: ${report.data.submissions.complete})`);
    console.log(`   User: ${report.data.users.total} (Migr√©s: ${report.data.users.migrated}, Admin: ${report.data.users.admin})`);
    
    // V√©rifications d'int√©grit√©
    console.log('\nüîç VERIFICATIONS D\'INTEGRITE:');
    
    Object.entries(report.integrity).forEach(([key, check]) => {
      const statusIcon = check.status === 'PASSED' ? '‚úÖ' : check.status === 'FAILED' ? '‚ùå' : '‚ö†Ô∏è';
      console.log(`   ${statusIcon} ${key}: ${check.status}`);
      
      if (check.status === 'FAILED' && check.details) {
        // Afficher les d√©tails des √©checs
        if (key === 'responsesToSubmissions') {
          if (check.details.orphanedResponses?.length > 0) {
            console.log(`      ‚Üí Responses orphelines: ${check.details.orphanedResponses.length}`);
          }
          if (check.details.dataIntegrityIssues?.length > 0) {
            console.log(`      ‚Üí Probl√®mes d'int√©grit√©: ${check.details.dataIntegrityIssues.length}`);
          }
        }
        
        if (key === 'userAccountCreation') {
          if (check.details.missingUserAccounts?.length > 0) {
            console.log(`      ‚Üí Comptes manquants: ${check.details.missingUserAccounts.length}`);
          }
          if (check.details.duplicateUsernames?.length > 0) {
            console.log(`      ‚Üí Doublons username: ${check.details.duplicateUsernames.length}`);
          }
        }
        
        if (key === 'dataConsistency') {
          const totalCorrupted = (check.details.corruptedResponses?.length || 0) + 
                               (check.details.corruptedSubmissions?.length || 0) + 
                               (check.details.corruptedUsers?.length || 0);
          if (totalCorrupted > 0) {
            console.log(`      ‚Üí Donn√©es corrompues: ${totalCorrupted}`);
          }
          if (check.details.orphanedData?.length > 0) {
            console.log(`      ‚Üí Donn√©es orphelines: ${check.details.orphanedData.length}`);
          }
        }
        
        if (key === 'relationshipValidity') {
          if (check.details.brokenRelationships?.length > 0) {
            console.log(`      ‚Üí Relations bris√©es: ${check.details.brokenRelationships.length}`);
          }
          if (check.details.statisticsErrors?.length > 0) {
            console.log(`      ‚Üí Erreurs statistiques: ${check.details.statisticsErrors.length}`);
          }
        }
        
        if (key === 'backwardCompatibility') {
          if (check.details.brokenTokens?.length > 0) {
            console.log(`      ‚Üí Tokens cass√©s: ${check.details.brokenTokens.length}`);
          }
          if (check.details.hybridSystemIssues?.length > 0) {
            console.log(`      ‚Üí Conflits syst√®me hybride: ${check.details.hybridSystemIssues.length}`);
          }
        }
      }
    });
    
    // Probl√®mes critiques
    if (report.summary.criticalIssues.length > 0) {
      console.log('\nüö® PROBLEMES CRITIQUES:');
      report.summary.criticalIssues.forEach((issue, index) => {
        console.log(`   ${index + 1}. [${issue.type}] ${issue.message}`);
        if (issue.details) {
          Object.entries(issue.details).forEach(([key, value]) => {
            console.log(`      - ${key}: ${value}`);
          });
        }
      });
    }
    
    // Recommandations prioritaires
    if (report.recommendations && report.recommendations.length > 0) {
      const highPriorityRecs = report.recommendations.filter(r => 
        r.priority === 'CRITICAL' || r.priority === 'HIGH'
      );
      
      if (highPriorityRecs.length > 0) {
        console.log('\nüí° RECOMMANDATIONS PRIORITAIRES:');
        highPriorityRecs.forEach((rec, index) => {
          const priorityEmoji = rec.priority === 'CRITICAL' ? 'üî•' : '‚ö†Ô∏è';
          console.log(`   ${index + 1}. ${priorityEmoji} [${rec.priority}] ${rec.title}`);
          console.log(`      Description: ${rec.description}`);
          console.log(`      Action: ${rec.action}`);
          console.log(`      Automatisable: ${rec.automatable ? 'Oui' : 'Non'}`);
        });
      }
    }
    
    // Performance
    console.log('\n‚ö° PERFORMANCE:');
    console.log(`   Temps d'ex√©cution: ${(report.performance.executionTime / 1000).toFixed(2)}s`);
    console.log(`   Requ√™tes DB: ${report.performance.queryStats.totalQueries}`);
    console.log(`   Temps moyen/requ√™te: ${report.performance.queryStats.averageQueryTime.toFixed(2)}ms`);
    console.log(`   M√©moire utilis√©e: ${Math.round(report.performance.memoryUsage.heapUsed / 1024 / 1024)}MB`);
  }

  async run() {
    console.log('üß™ TEST D\'INTEGRITE COMPLET AVEC MONGODB MEMORY SERVER');
    console.log('====================================================');
    console.log(`üìÖ D√©marr√© le: ${new Date().toLocaleString()}`);
    
    let success = false;
    let report = null;
    
    try {
      // D√©marrage du serveur MongoDB en m√©moire
      const mongoStarted = await this.startMongoMemoryServer();
      if (!mongoStarted) {
        return false;
      }
      
      // G√©n√©ration des donn√©es de test
      const dataGenerated = await this.generateTestData();
      if (!dataGenerated) {
        console.error('‚ùå √âchec de la g√©n√©ration des donn√©es de test');
        return false;
      }
      
      // Ex√©cution de la v√©rification d'int√©grit√©
      report = await this.runIntegrityCheck();
      if (!report) {
        console.error('‚ùå √âchec de la v√©rification d\'int√©grit√©');
        return false;
      }
      
      // Affichage des r√©sultats d√©taill√©s
      await this.displayDetailedResults(report);
      
      success = report.summary.status === 'PASSED' || report.summary.status === 'WARNING';
      
    } catch (error) {
      console.error('üí• Erreur fatale pendant l\'ex√©cution:', error);
      success = false;
    } finally {
      // Nettoyage
      await this.stopMongoMemoryServer();
    }
    
    console.log('\nüèÅ Test d\'int√©grit√© termin√©');
    
    if (success) {
      console.log('üéâ Test r√©ussi - Int√©grit√© des donn√©es valid√©e!');
    } else {
      console.log('‚ùå Test √©chou√© - Probl√®mes d\'int√©grit√© d√©tect√©s');
    }
    
    return { success, report };
  }
}

// Ex√©cution si appel√© directement
if (require.main === module) {
  const runner = new IntegrityTestRunner();
  runner.run().then(({ success, report }) => {
    if (success) {
      console.log('\n‚úÖ CONCLUSION: Migration FAF valid√©e avec succ√®s!');
      process.exit(0);
    } else {
      console.log('\n‚ùå CONCLUSION: Migration FAF n√©cessite des corrections');
      process.exit(1);
    }
  }).catch((error) => {
    console.error('üí• Erreur critique:', error);
    process.exit(2);
  });
}

module.exports = IntegrityTestRunner;