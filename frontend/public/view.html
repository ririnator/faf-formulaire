<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Vos r√©ponses</title>
  <link rel="stylesheet" href="/css/view.css">
</head>
<body>
  <div class="match-header">
    <div class="team team-left">
      <div class="team-name" id="user-name"></div>
    </div>
    <div class="vs-section">
      <div class="match-info" id="month"></div>
    </div>
    <div class="team team-right">
      <div class="team-name" id="admin-name"></div>
    </div>
  </div>
  
  <div id="qa-container"></div>

  <!-- Modal pour afficher les images en grand -->
  <div id="imageModal" style="display:none; position:fixed; z-index:1000; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); cursor:pointer; overflow:hidden;">
    <img id="modalImage" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); max-width:90%; max-height:90%; border-radius:8px; cursor:default; transition: all 0.3s ease;">
    <span id="closeModal" style="position:absolute; top:20px; right:35px; color:#f1f1f1; font-size:40px; font-weight:bold; cursor:pointer; background:rgba(0,0,0,0.5); border-radius:50%; width:50px; height:50px; display:flex; align-items:center; justify-content:center; user-select:none; z-index:1002;">&times;</span>
    <div id="modalLoading" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#f1f1f1; font-size:18px; display:none;">Chargement...</div>
  </div>

  <script>
    // Fonction pour d√©coder uniquement les entit√©s HTML s√ªres (liste blanche)
    function unescapeHTML(text) {
      if (!text || typeof text !== 'string') return text || '';
      
      // Approche liste blanche : d√©coder uniquement les entit√©s communes et s√ªres
      const safeEntityMap = {
        '&#x27;': "'",
        '&#39;': "'",
        '&apos;': "'",
        '&quot;': '"',
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&nbsp;': ' ',
        '&eacute;': '√©',
        '&egrave;': '√®',
        '&ecirc;': '√™',
        '&agrave;': '√†',
        '&acirc;': '√¢',
        '&ugrave;': '√π',
        '&ucirc;': '√ª',
        '&icirc;': '√Æ',
        '&ocirc;': '√¥',
        '&ccedil;': '√ß'
      };
      
      let result = text;
      for (const [entity, char] of Object.entries(safeEntityMap)) {
        result = result.replace(new RegExp(entity, 'g'), char);
      }
      
      return result;
    }

    // Fonction pour formater le mois en fran√ßais
    function formatMonth(monthString) {
      if (!monthString || typeof monthString !== 'string') return monthString || '';
      
      const monthNames = {
        '01': 'Janvier',
        '02': 'F√©vrier', 
        '03': 'Mars',
        '04': 'Avril',
        '05': 'Mai',
        '06': 'Juin',
        '07': 'Juillet',
        '08': 'Ao√ªt',
        '09': 'Septembre',
        '10': 'Octobre',
        '11': 'Novembre',
        '12': 'D√©cembre'
      };
      
      // Format attendu: "YYYY-MM" -> "Mois YYYY"
      const parts = monthString.split('-');
      if (parts.length === 2) {
        const year = parts[0];
        const month = parts[1];
        const monthName = monthNames[month];
        
        if (monthName) {
          return `${monthName} ${year}`;
        }
      }
      
      // Si le format n'est pas reconnu, retourner tel quel
      return monthString;
    }

    // Optimisation performance mobile : d√©tecter mobile au d√©but (globalement accessible)
    const isMobile = window.innerWidth <= 600;
    
    // Gestion Panzoom et modal
    let panzoomInstance = null, wheelHandler = null, tapTimeout = null, modalCleanup = null;
    let openerEl = null, bodyScrollY = 0;

    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const closeBtn = document.getElementById('closeModal');

    if (!modal || !modalImg || !closeBtn) {
      console.error('Modal elements not found');
    }
    const qaContainer = document.getElementById('qa-container');
    const hasTouchScreen = (navigator.maxTouchPoints || 0) > 0;
    
    // Lock/unlock body sans scroll jump
    function lockBody(){
      bodyScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
      document.body.style.cssText = `position:fixed;top:-${bodyScrollY}px;width:100%;`;
    }

    function unlockBody(){
      document.body.style.cssText = '';
      window.scrollTo(0, bodyScrollY);
    }

    // Optimisation Cloudinary mobile
    function cldMobile(url){
      if (!url || !url.includes('/upload/')) return url;
      const hasW   = /(^|[,/?])w_\d+($|[,/?])/i.test(url);
      const hasF   = /(^|[,/?])f_auto($|[,/?])/i.test(url);
      const hasQ   = /(^|[,/?])q_auto($|[,/?])/i.test(url);
      const hasDpr = /(^|[,/?])dpr_auto($|[,/?])/i.test(url);
      if (hasW && hasF && hasQ && hasDpr) return url;
      return url.replace('/upload/','/upload/f_auto,q_auto,w_1200,dpr_auto/');
    }

    // Chargement Panzoom dynamique
    async function loadPanzoom(){
      if (window.Panzoom) return window.Panzoom;
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js';
      document.head.appendChild(s);
      return new Promise(res=>{
        s.onload = ()=>res(window.Panzoom);
        s.onerror= ()=>{ console.error('Panzoom CDN failed'); res(null); };
      });
    }
    
    (async () => {
      try {
        const token = location.pathname.split('/').pop();
        if (!token || token.length < 10) {
          throw new Error('Token invalide dans l\'URL');
        }
        
        const res = await fetch(`/api/view/${token}`);
        
        // V√©rifier la r√©ponse HTTP
        if (!res.ok) {
          if (res.status === 404) {
            throw new Error('Lien invalide ou expir√©');
          } else if (res.status === 500) {
            throw new Error('Erreur serveur. Veuillez r√©essayer plus tard.');
          } else {
            throw new Error(`Erreur ${res.status}: ${res.statusText}`);
          }
        }
        
        // Parser le JSON avec gestion d'erreur
        let data;
        try {
          data = await res.json();
        } catch (jsonError) {
          console.error('Erreur de parsing JSON:', jsonError);
          throw new Error('R√©ponse invalide du serveur');
        }
        
        // Valider la structure des donn√©es
        if (!data || typeof data !== 'object') {
          throw new Error('Format de donn√©es invalide');
        }
        
        const { user, admin, adminName } = data;
        
        // V√©rifier que l'utilisateur existe
        if (!user || !user.responses || !Array.isArray(user.responses)) {
          throw new Error('Donn√©es utilisateur manquantes ou invalides');
        }
        
        // Mettre √† jour l'interface de mani√®re s√©curis√©e
        const userNameEl = document.getElementById('user-name');
        const adminNameEl = document.getElementById('admin-name');
        const monthEl = document.getElementById('month');
        
        if (userNameEl) userNameEl.textContent = user.name || 'Utilisateur';
        if (adminNameEl) adminNameEl.textContent = adminName || 'Admin';
        if (monthEl) monthEl.textContent = formatMonth(user.month);

      // Configuration du regroupement des questions
      const questionGroups = [
        { name: "Audit mental", questions: [0, 1] }, // Q1-Q2: Comment √ßa va + d√©tails
        { name: "Check personnel", questions: [2] }, // Q3: Photo de toi
        { name: "Culture & flex", questions: [3, 4, 6] }, // Q4: Truc cool, Q5: Reaction pic, Q7: D√©couverte culturelle  
        { name: "R√©flexions & conversations", questions: [5, 7] }, // Q6: Conversation int√©ressante, Q8: Habitudes/routines
        { name: "Appel √† un ami", questions: [8] }, // Q9: Probl√®me/opinions tierces
        { name: "Connexion √† la nature", questions: [9] }, // Q10: Photo avec herbe/arbre
        { name: "Champ libre", questions: [10] } // Q11: Champ libre (optionnel)
      ];

      // Fonction pour d√©tecter et afficher une image s√©curis√©e
      function createAnswerContent(answer) {
        const container = document.createElement('span');
        
        // üîí SECURITY: Only allow trusted image domains (whitelist approach)
        const TRUSTED_IMAGE_DOMAINS = [
          'res.cloudinary.com',           // Cloudinary CDN (notre service upload)
          'images.unsplash.com',          // Unsplash (si utilis√© pour placeholder)
          'via.placeholder.com',          // Placeholder service (si n√©cessaire)
          // Ajouter d'autres domaines de confiance si n√©cessaire
        ];
        
        // Strict validation: URL must be HTTPS and from trusted domain
        function isTrustedImageUrl(url) {
          if (!url || typeof url !== 'string') return false;
          
          // V√©rifier d'abord si √ßa ressemble √† une URL avant d'essayer de la parser
          if (!url.startsWith('http://') && !url.startsWith('https://')) return false;
          
          try {
            const urlObj = new URL(url);
            
            // 1. Force HTTPS only
            if (urlObj.protocol !== 'https:') return false;
            
            // 2. Check if domain is in whitelist
            const hostname = urlObj.hostname.toLowerCase();
            const isTrustedDomain = TRUSTED_IMAGE_DOMAINS.some(domain => 
              hostname === domain || hostname.endsWith('.' + domain)
            );
            if (!isTrustedDomain) return false;
            
            // 3. Special handling for Cloudinary URLs (don't always have extensions)
            const pathname = urlObj.pathname;
            if (hostname === 'res.cloudinary.com' || hostname.endsWith('.cloudinary.com')) {
              // Cloudinary URLs follow pattern: /cloud_name/image/upload/...
              // They're trusted if they match the domain, regardless of extension
              if (!pathname.includes('/image/upload/')) return false;
            } else {
              // For other domains, verify file extension for images (case insensitive)
              const pathLower = pathname.toLowerCase();
              const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
              const hasValidExtension = validExtensions.some(ext => 
                pathLower.includes(ext)
              );
              if (!hasValidExtension) return false;
            }
            
            return true;
          } catch (e) {
            // Invalid URL format
            return false;
          }
        }
        
        if ((answer.startsWith('http://') || answer.startsWith('https://')) && isTrustedImageUrl(answer)) {
          const img = document.createElement('img');
          img.src = answer;
          img.alt = 'Image partag√©e';
          // Pas de styles inline pour permettre au CSS responsive de s'appliquer
          img.className = 'response-image';
          
          // üîí SECURITY: Enhanced error handling without exposing URLs
          img.onerror = function() {
            // Remplacer l'image par un message d'erreur
            const errorMsg = document.createElement('em');
            errorMsg.textContent = 'Image temporairement indisponible';
            errorMsg.style.color = '#888';
            this.replaceWith(errorMsg);
          };
          
          // üîí SECURITY: Add CSP-friendly loading attribute
          img.loading = 'lazy';
          
          // Optimisation mobile : observer pour mesurer les performances
          if (isMobile && 'IntersectionObserver' in window) {
            const imgObserver = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  // Image devient visible, on peut d√©clencher des optimisations si n√©cessaire
                  entry.target.classList.add('visible');
                  imgObserver.unobserve(entry.target);
                }
              });
            });
            imgObserver.observe(img);
          }
          
          // Ajouter la classe pour la d√©l√©gation d'√©v√©nement
          img.className = 'response-image';
          img.style.cursor = 'pointer';
          
          container.appendChild(img);
        } else {
          container.textContent = answer;
        }
        
        return container;
      }

      // Affichage en format 1vs1 - Questions au centre, r√©ponses de chaque c√¥t√©
      questionGroups.forEach((group, groupIndex) => {
        const groupBlock = document.createElement('div');
        groupBlock.className = 'question-group';
        
        // Mobile : ne charger que le premier groupe initialement
        if (isMobile && groupIndex > 0) {
          groupBlock.style.display = 'none';
          groupBlock.dataset.loaded = 'false';
        }

        const groupTitle = document.createElement('div');
        groupTitle.className = 'group-title';
        groupTitle.textContent = group.name;
        groupBlock.appendChild(groupTitle);

        group.questions.forEach(questionIndex => {
          // V√©rifier que l'index est valide et que la r√©ponse existe
          if (questionIndex >= 0 && questionIndex < user.responses.length && user.responses[questionIndex]) {
            const q = user.responses[questionIndex];
            
            // D√©coder les entit√©s HTML de mani√®re s√©curis√©e avec validation
            const question = q.question ? unescapeHTML(q.question) : 'Question non disponible';
            const answer = q.answer ? unescapeHTML(q.answer) : '';

            // Container 1vs1 pour cette question
            const matchContainer = document.createElement('div');
            matchContainer.className = 'match-container';

            // R√©ponse utilisateur (gauche)
            const userSide = document.createElement('div');
            userSide.className = 'player-side user-side';
            
            const userAnswer = document.createElement('div');
            userAnswer.className = 'answer-content';
            userAnswer.appendChild(createAnswerContent(answer));
            userSide.appendChild(userAnswer);

            // Question au centre
            const questionCenter = document.createElement('div');
            questionCenter.className = 'question-center';
            
            const questionNumber = document.createElement('div');
            questionNumber.className = 'question-number';
            questionNumber.textContent = `Q${questionIndex+1}`;
            
            const questionText = document.createElement('div');
            questionText.className = 'question-text';
            questionText.textContent = question;
            
            questionCenter.appendChild(questionNumber);
            questionCenter.appendChild(questionText);

            // R√©ponse admin (droite)
            const adminSide = document.createElement('div');
            adminSide.className = 'player-side admin-side';
            
            const adminAnswer = document.createElement('div');
            adminAnswer.className = 'answer-content';
            
            // V√©rifier soigneusement l'existence de admin et de ses propri√©t√©s
            if (admin && admin.responses && Array.isArray(admin.responses) && 
                questionIndex < admin.responses.length && admin.responses[questionIndex] &&
                admin.responses[questionIndex].answer) {
              const adminAnswerText = unescapeHTML(admin.responses[questionIndex].answer);
              adminAnswer.appendChild(createAnswerContent(adminAnswerText));
            } else {
              const emElement = document.createElement('em');
              emElement.textContent = 'Pas encore r√©pondu';
              emElement.className = 'no-answer';
              adminAnswer.appendChild(emElement);
            }
            adminSide.appendChild(adminAnswer);

            // Assemblage du match
            matchContainer.appendChild(userSide);
            matchContainer.appendChild(questionCenter);
            matchContainer.appendChild(adminSide);
            
            groupBlock.appendChild(matchContainer);
          }
        });

        document.getElementById('qa-container').appendChild(groupBlock);
      });

      // Lazy loading des groupes sur mobile (utilise la m√™me d√©tection)
      if (isMobile) {
        let loadedGroups = 1; // Premier groupe d√©j√† charg√©
        const allGroups = document.querySelectorAll('.question-group');
        
        function loadNextGroup() {
          if (loadedGroups < allGroups.length) {
            const nextGroup = allGroups[loadedGroups];
            nextGroup.style.display = 'block';
            nextGroup.dataset.loaded = 'true';
            loadedGroups++;
          }
        }
        
        // Charger le groupe suivant quand on approche du bas
        let loadingNext = false;
        
        // V√©rifier imm√©diatement si la page est trop courte pour scroller
        setTimeout(() => {
          const windowHeight = window.innerHeight;
          const documentHeight = document.documentElement.scrollHeight;
          
          // Si la page ne d√©file pas (hauteur insuffisante), charger tous les groupes
          if (documentHeight <= windowHeight + 100) {
            while (loadedGroups < allGroups.length) {
              loadNextGroup();
            }
            return;
          }
        }, 200); // Laisser le temps au DOM de se mettre en place
        
        window.addEventListener('scroll', () => {
          if (loadingNext) return;
          
          const scrollTop = window.scrollY;
          const windowHeight = window.innerHeight;
          const documentHeight = document.documentElement.scrollHeight;
          
          // Charger quand il reste 200px √† faire d√©filer
          if (scrollTop + windowHeight >= documentHeight - 200) {
            loadingNext = true;
            setTimeout(() => {
              loadNextGroup();
              loadingNext = false;
            }, 100); // Petite pause pour √©viter le spam
          }
        });
        }
      }
      } catch (error) {
        console.error('Erreur lors du chargement des donn√©es:', error);
        
        // Afficher un message d'erreur d√©taill√© √† l'utilisateur
        const errorContainer = document.createElement('div');
        errorContainer.style.cssText = 'padding: 20px; text-align: center; color: #d32f2f; font-family: system-ui, -apple-system, sans-serif;';
        
        const errorTitle = document.createElement('h2');
        errorTitle.textContent = '‚ö†Ô∏è Erreur de chargement';
        errorTitle.style.marginBottom = '10px';
        
        const errorMessage = document.createElement('p');
        errorMessage.textContent = error.message || 'Une erreur inattendue s\'est produite';
        errorMessage.style.marginBottom = '20px';
        
        const retryButton = document.createElement('button');
        retryButton.textContent = 'R√©essayer';
        retryButton.style.cssText = 'padding: 10px 20px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;';
        retryButton.onclick = () => location.reload();
        
        errorContainer.appendChild(errorTitle);
        errorContainer.appendChild(errorMessage);
        errorContainer.appendChild(retryButton);
        
        // Nettoyer et afficher l'erreur
        document.body.innerHTML = '';
        document.body.appendChild(errorContainer);
        return; // Sortir si erreur
      }

      // ===== GESTION DU MODAL D'IMAGE (apr√®s cr√©ation du contenu) =====
      setupImageModal();
    })();
    
    // Fonction pour configurer le modal d'image
    function setupImageModal() {
      const modal = document.getElementById('imageModal');
      const modalImg = document.getElementById('modalImage');
      const closeBtn = document.getElementById('closeModal');
      const qaContainer = document.getElementById('qa-container');

      if (!modal || !modalImg || !closeBtn) {
        console.error('Modal elements not found');
        return;
      }

      if (!qaContainer) {
        console.error('QA container not found');
        return;
      }

      console.log('Setting up image modal...');

      // Variables locales pour le modal
      let panzoomInstance = null, wheelHandler = null, tapTimeout = null, modalCleanup = null;
      let openerEl = null, bodyScrollY = 0;

      // Lock/unlock body sans scroll jump
      function lockBody(){
        bodyScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
        document.body.style.cssText = `position:fixed;top:-${bodyScrollY}px;width:100%;`;
      }

      function unlockBody(){
        document.body.style.cssText = '';
        window.scrollTo(0, bodyScrollY);
      }

      // Fonction s√©par√©e pour initialiser Panzoom
      async function initPanzoomAsync() {
        try {
          const Panzoom = await loadPanzoom();
          
          if (Panzoom && modal.style.display === 'block') {
            // Clean up previous instance
            try { panzoomInstance?.destroy?.(); } catch {}
            
            panzoomInstance = Panzoom(modalImg, {
              maxScale: 4, 
              minScale: 1, 
              contain: 'outside', 
              animate: true, 
              duration: 200
            });

            // Wheel zoom
            wheelHandler = (ev) => {
              ev.preventDefault();
              panzoomInstance?.zoomWithWheel(ev);
            };
            modal.addEventListener('wheel', wheelHandler);

            // Double-tap zoom
            const handleDblTap = (ev) => {
              if (tapTimeout) {
                clearTimeout(tapTimeout); 
                tapTimeout = null;
                const scale = panzoomInstance.getScale();
                panzoomInstance.zoomToPoint(scale === 1 ? 2 : 1, ev);
              } else {
                tapTimeout = setTimeout(() => tapTimeout = null, 300);
              }
            };
            modalImg.addEventListener('pointerup', handleDblTap);

            // Cleanup function
            modalCleanup = () => {
              clearTimeout(tapTimeout); tapTimeout = null;
              if (wheelHandler) { 
                modal.removeEventListener('wheel', wheelHandler); 
                wheelHandler = null; 
              }
              modalImg.removeEventListener('pointerup', handleDblTap);
              try { panzoomInstance?.destroy?.(); } catch {}
              panzoomInstance = null;
            };

            modalImg.style.cursor = 'move';
            console.log('Panzoom initialized successfully');
          }
        } catch (err) {
          console.error('Panzoom initialization failed:', err);
          modalImg.style.cursor = 'default';
        }
      }

      function closeModal(){
        // Cleanup Panzoom et handlers
        modalCleanup?.(); 
        modalCleanup = null;

        // Reset modal state
        const loadingEl = document.getElementById('modalLoading');
        if (loadingEl) {
          loadingEl.style.display = 'none';
          loadingEl.textContent = 'Chargement...';
        }

        // Fermer modal
        modal.style.display = 'none';
        modalImg.style.display = 'block';
        modalImg.style.willChange = 'auto';
        modalImg.style.cursor = 'default';
        modalImg.removeAttribute('srcset');
        modalImg.removeAttribute('sizes');
        modalImg.onload = null;
        modalImg.onerror = null;
        modalImg.src = '';

        // Nettoyer indicateurs
        modal.querySelectorAll('.modal-indicator').forEach(n=>n.remove());

        // Restaurer body scroll
        unlockBody();
        
        // Rendre focus
        openerEl?.focus?.(); 
        openerEl = null;
      }
    
      // Gestion d'ouverture du modal - version simplifi√©e et plus robuste
      qaContainer.addEventListener('click', (e) => {
        // V√©rifier si c'est bien une image cliqu√©e
        const img = e.target;
        if (!img || !img.classList || !img.classList.contains('response-image')) return;
        if (!modal || !modalImg || !closeBtn) {
          console.error('Modal elements missing');
          return;
        }

        // Emp√™cher la propagation
        e.preventDefault();
        e.stopPropagation();

        console.log('Opening modal for image:', img.src);

        // Ouvrir le modal avec indicateur de chargement
        openerEl = img;
        lockBody();
        modal.style.display = 'block';
        
        // Afficher loading pendant le chargement de l'image
        const loadingEl = document.getElementById('modalLoading');
        if (loadingEl) {
          loadingEl.style.display = 'block';
        }
        modalImg.style.display = 'none';

        // Pr√©charger l'image
        const imgSrc = img.src || '';
        modalImg.onload = () => {
          if (loadingEl) loadingEl.style.display = 'none';
          modalImg.style.display = 'block';
          modalImg.style.cursor = 'default';
        };
        modalImg.onerror = () => {
          if (loadingEl) {
            loadingEl.textContent = 'Erreur de chargement de l\'image';
            setTimeout(() => closeModal(), 2000);
          }
        };
        
        // D√©finir l'image dans le modal
        modalImg.src = imgSrc;
        modalImg.alt = img.alt || 'Image';

        // Initialiser Panzoom de mani√®re asynchrone (non-bloquante)
        initPanzoomAsync();

      }, { passive: false }); // Non-passive pour pouvoir preventDefault
      
      // Event listeners de fermeture
      closeBtn.addEventListener('click', closeModal, { passive: true });
      modal.addEventListener('click', (e)=>{ if (e.target === modal) closeModal(); }, { passive: true });
      document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && modal.style.display === 'block') closeModal(); });
    }
  </script>
</body>
</html>